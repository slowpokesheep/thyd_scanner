%{
  import java.io.*;
  import java.util.*;
%}

%token <sval> LITERAL, NAME
%token IF, ELSE, ELSIF, WHILE, VAR
%token RETURN, OPNAME, AND, OR, NOT

%type <obj> program

%%

start
: program { generateProgram(name, ((Vector<Object>)($1)).toArray()); }
;

%%

private NanoMorphoLexer lexer;
// The symbol table consists of the following two variables.
private static int varCount;
private static HashMap<String,Integer> varTable;

private static String name;
private int last_token_read;


// Adds a new variable to the symbol table.
// Throws Error if the variable already exists.
private void addVar(String name) {

  if (varTable.get(name) != null) {
    throw new Error("Variable "+name+" already exists, near line " + lexer.getLine() + 1);
  }
    varTable.put(name,varCount++);
}

// Finds the location of an existing variable.
// Throws Error if the variable does not exist.
private int findVar(String name) {
  Integer res = varTable.get(name);

  if (res == null) {
    throw new Error("Variable "+name+" does not exist, near line " + lexer.getLine() + 1);
  }
    return res;
}

private int yylex() {
  int yyl_return = -1;
  try {
    yylval = null;
    last_token_read = yyl_return = lexer.yylex();

    if (yylval == null ) {
      yylval = new NanoMorphoParserVal(NanoMorphoParser.yyname[yyl_return]);
    }
  }
  catch (IOException e) {
    System.err.println("IO error: " + e);
  }
  return yyl_return;
}

public void yyerror(String error) {
  System.out.println("Error:  " + error);
  System.out.println("Token:  " + NanoMorphoParser.yyname[last_token_read]);
  System.out.printf("Line: %d, Column: %d\n", lexer.getLine(), lexer.getColumn());
  System.exit(1);
}

public NanoMorphoParser(Reader r) {
  lexer = new NanoMorphoLexer(r, this);
}

public static void main(String args[]) throws IOException {
  NanoMorphoParser yyparser = new NanoMorphoParser(new FileReader(args[0]));
  name = args[0].substring(0, args[0].lastIndexOf('.'));
  yyparser.yyparse();
}

// GENERATE - TODO FIX

private static int nextLab = 0;

// Returns a new, previously unused, label.
// Useful for control-flow expressions.
static String newLabel() {
    return "_"+(nextLab++);
}

public int newIntLabel() {
  return nextLab++;
}

public void print(String s) {
  //System.out.println(s);
  writer.println(s);
}

// Final code

public void generateProgram(String programname, Object[] funs) {
  print("\""+programname+".mexe\" = main in");
  print("!");
  print("{{");
  
  for (Object f: funs) {
    generateFunction((Object[]) f);
  }

  print("}}");
  print("*");
  print("BASIS;");
}

// [functionName, argCount, varCount, exprs]
public void generateFunction(Object[] fun) {
  String functionName = (String) fun[0];
  int argCount = (Integer) fun[1];
  int varCount = (Integer) fun[2];
  Object[] exprs = (Object[]) fun[3];

  print("#\"" +functionName+ "[f" +argCount+ "]\" =");
  print("[");


  for (int i = 0; i < varCount; ++i) {
    print("(MakeVal null)");
    print("(Push)");
  }

  for (Object e: exprs) {
    generateExpr((Object[]) e);
  }


  print("(Return)");
  print("];");
}

// RETURN, STORE, OR, AND, NOT, CALL, FETCH, LITERAL, IF, WHILE, BODY
public void generateExpr(Object[] e) {

  switch((type) e[0]) {
    case RETURN: // ["RETURN", expr]
      generateExpr((Object[]) e[1]);
      print("(Return)");
      break;
    case STORE: // ["STORE", pos, expr]
      generateExpr((Object[]) e[2]);
      print("(Store "+e[1]+")");
      break;
    case NOT: // ["NOT", expr]
      generateExpr((Object[]) e[1]);
      print("(Not)");
      break;
    case CALL: // ["CALL", name, args]
      Object[] args = (Object[]) e[2];

      for (Object arg: args) {
        print("(Push)");
        generateExpr((Object[]) arg);
      }

      print("(Call #\""+e[1]+"[f"+args.length+"]\" "+args.length+")");
      break;
    case FETCH: // ["FETCH", pos]
      print("(Fetch "+e[1]+")");
      break;
    case LITERAL:
      print("(MakeVal "+e[1]+")");
      break;
    case IF: // ["IF", expr, expr, expr]
      
      int labelElse = newIntLabel();
      int labelEnd = newIntLabel();

      Object[] then = (Object[]) e[2];

      if ((e[1] instanceof Boolean)) {
        generateExpr(then);
        print("(Go _"+labelEnd+")");
        print("_"+labelElse+":");
        print("_"+labelEnd+":");
        return;
      }
      Object[] cond = (Object[]) e[1];

      generateJump(cond, 0, labelElse);
      generateExpr(then);

      print("(Go _"+labelEnd+")");
      print("_"+labelElse+":");

      Object[] els = (Object[]) e[3];
      if (els != null) {
        generateExpr(els);
      }

      print("_"+labelEnd+":");
      break;
    case WHILE: // ["WHILE", expr, expr]
      String labelStart = newLabel();
      String labelStop = newLabel();

      print("(Go "+labelStop+")");
      print(""+labelStart+":");

      generateBody((Object[]) e[2]);

      print(""+labelStop+":");

      generateExpr((Object[]) e[1]);
      print("(GoTrue "+labelStart+")");
      break;
    case BODY: // ["BODY", expr]
      generateBody(e);
      break;
    default:
      break;
  }
}

public void generateBody(Object[] e) {
  
  for (Object expr: (Object[]) e[1]) {
    generateExpr((Object[]) expr);
  }
}

public void generateJump(Object[] e, int labelTrue, int labelFalse) {
  generateExpr(e);
  if (labelTrue != 0 ) print("(GoTrue _"+labelTrue+")");
  if (labelFalse != 0 ) print("(GoFalse _"+labelFalse+")");
}